# Improved workflow: Bump Flatpak runtime/sdk versions across all branches
# - Addresses two common failures you reported:
#   1) "Push failed ... (may be protected)" — branch protection prevents pushing to target repository.
#   2) "Failed to create PR ... Response code: 422" — often caused by a duplicate PR or invalid head (branch already exists
#      in the same repo / PR already exists), or invalid request body.
#
# Strategy / fixes implemented:
# - Before creating a PR, check if a PR with the same head/base already exists; if one exists, skip creating a duplicate PR.
# - If pushing to the main repo fails (likely because branch protection prevents creating the branch), the job:
#    a) optionally creates a fork of the repo (if not already present),
#    b) pushes the update branch to the fork (so branch protection on upstream doesn't block it),
#    c) creates the PR from fork:branch -> upstream:target_branch.
# - Pushing to forks or writing branches may require a PAT with repo scope. The workflow uses:
#    - secrets.GITHUB_TOKEN for default operations (no extra permissions needed for simple repos)
#    - optional secrets.PERSONAL_ACCESS_TOKEN (recommended) to allow pushing to forks and more robust write actions.
#
# How to use:
# 1) (recommended) Add a personal access token (classic) with "repo" scope to this repository's secrets as PERSONAL_ACCESS_TOKEN.
#    - If you don't supply it, the workflow will try with GITHUB_TOKEN and will still handle duplicate PRs and skip protected branches.
# 2) Go to Actions -> "Bump Flatpak runtime/sdk versions" -> Run workflow and provide:
#    - version (e.g., 47)
#    - branch-glob-exclude (optional) to skip branches like ^dependabot/
#    - skip-protected-branches: if true, the workflow will skip protected branches entirely;
#      if false, it will attempt to push to a fork instead.
#
# Notes:
# - The workflow will log the reason when it falls back to using a fork.
# - The workflow will not overwrite existing update branches on the upstream repo; if an update branch already exists,
#   it will attempt to create a branch on the fork or skip if duplicate.
# - The workflow checks for existing PRs (same head & base) and will not create duplicate PRs (avoids 422 caused by dup PRs).
#
name: Bump Flatpak runtime/sdk versions

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Target runtime/sdk version (e.g. 47)'
        required: true
        default: '47'
      branch-glob-exclude:
        description: 'Optional: regex to exclude branches (e.g. ^dependabot/)'
        required: false
        default: ''
      skip-protected-branches:
        description: 'If true, skip protected branches (default: true). If false, workflow will try using a fork when push is blocked.'
        required: false
        default: 'true'

permissions:
  contents: write
  pull-requests: write

jobs:
  bump-versions:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (fetch all branches)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (jq, yq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq gettext-base
          YQ_VERSION=v4.40.2
          wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          chmod +x /usr/local/bin/yq
          yq --version

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Prepare inputs
        id: inputs
        run: |
          echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          echo "EXCLUDE=${{ github.event.inputs.branch-glob-exclude }}" >> $GITHUB_OUTPUT
          echo "SKIP_PROTECTED=${{ github.event.inputs.skip-protected-branches }}" >> $GITHUB_OUTPUT

      - name: List remote branches (save JSON)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${REPO}/branches?per_page=100" > /tmp/branches.json
          jq -r '.[].name' /tmp/branches.json > /tmp/branch-names.txt
          echo "Branches saved to /tmp/branch-names.txt"

      - name: Update branches and open PRs (handles protected + 422)
        env:
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PAT: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          VERSION: ${{ steps.inputs.outputs.VERSION }}
          EXCLUDE: ${{ steps.inputs.outputs.EXCLUDE }}
          SKIP_PROTECTED: ${{ steps.inputs.outputs.SKIP_PROTECTED }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.git"
          BRANCHES_FILE=/tmp/branches.json
          ROOT=$(pwd)

          # helper: check if a PR already exists with same head and base
          pr_exists() {
            local head_repo=$1 head_branch=$2 base_branch=$3
            # Query PRs with head (format: owner:branch) and base
            # We will list open PRs and check if one matches
            q="https://api.github.com/repos/${REPO}/pulls?state=open&per_page=100"
            resp=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$q")
            echo "$resp" | jq -e --arg head "${head_repo}:${head_branch}" --arg base "${base_branch}" '.[] | select((.head.repo.full_name + ":" + .head.ref) == $head) | select(.base.ref == $base) | .html_url' >/dev/null 2>&1
          }

          # helper: check whether branch on upstream is protected
          is_protected() {
            local branch=$1
            status=$(curl -s -o /tmp/branch_prot.json -w "%{http_code}" -H "Authorization: token ${GITHUB_TOKEN}" \
              "https://api.github.com/repos/${REPO}/branches/${branch}/protection")
            if [[ "$status" == "200" ]]; then
              echo "true"
            else
              echo "false"
            fi
          }

          # helper: ensure fork exists and return fork repo full_name (owner/repo)
          ensure_fork() {
            # If PAT is not provided, we can't reliably create a fork and push — return empty
            if [[ -z "${PAT:-}" ]]; then
              echo ""
              return
            fi
            # whoami via PAT
            owner=$(curl -s -H "Authorization: token ${PAT}" https://api.github.com/user | jq -r .login)
            fork_full="${owner}/$(basename ${REPO})"
            # check if fork exists
            code=$(curl -s -o /tmp/check_fork.json -w "%{http_code}" -H "Authorization: token ${PAT}" "https://api.github.com/repos/${fork_full}")
            if [[ "$code" == "200" ]]; then
              echo "${fork_full}"
              return
            fi
            # create fork
            echo "Creating fork ${fork_full} via API..."
            create_resp_code=$(curl -s -o /tmp/create_fork.json -w "%{http_code}" -X POST -H "Authorization: token ${PAT}" "https://api.github.com/repos/${REPO}/forks")
            if [[ "$create_resp_code" == "202" || "$create_resp_code" == "201" ]]; then
              echo "${fork_full}"
              # wait for fork to be ready
              for i in 1 2 3 4 5; do
                sleep 2
                code2=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${PAT}" "https://api.github.com/repos/${fork_full}")
                if [[ "$code2" == "200" ]]; then break; fi
              done
              echo "${fork_full}"
              return
            else
              echo ""
              return
            fi
          }

          # iterate branches
          jq -r '.[].name' "$BRANCHES_FILE" | while IFS= read -r target_branch; do
            if [[ -n "${EXCLUDE}" ]] && echo "$target_branch" | grep -E "${EXCLUDE}" >/dev/null 2>&1; then
              echo "Skipping branch (excluded): $target_branch"
              continue
            fi

            protected="false"
            if [[ "${SKIP_PROTECTED}" == "true" ]]; then
              protected=$(is_protected "$target_branch")
              if [[ "$protected" == "true" ]]; then
                echo "Branch $target_branch is protected and skip-protected-branches=true -> skipping"
                continue
              fi
            fi

            safe_branch="update/sdk-runtime-${VERSION}-${target_branch//\//-}"
            workdir="/tmp/wt-${safe_branch}"
            rm -rf "$workdir"
            mkdir -p "$workdir"

            echo "Processing branch: $target_branch -> new branch: $safe_branch (workdir: $workdir)"
            git fetch origin "$target_branch":"refs/remotes/origin/${target_branch}" || true
            git worktree add --detach "$workdir" "origin/${target_branch}" || { echo "Failed to add worktree for ${target_branch}"; continue; }
            pushd "$workdir" >/dev/null

            git checkout -b "$safe_branch" || { echo "Failed to checkout new branch $safe_branch"; popd >/dev/null; git worktree remove "$workdir" --force || true; continue; }

            changed=false
            notes=()
            files=$(git ls-files -- '*.json' '*.yaml' '*.yml' '*.jsonnet' '*.xml' || true)
            for f in $files; do
              updated=false
              if [[ "$f" =~ \.json$ ]]; then
                if jq empty "$f" >/dev/null 2>&1; then
                  if jq -e --arg v "${VERSION}" 'has("runtime-version") and .["runtime-version"] != $v' "$f" >/dev/null 2>&1; then
                    jq ".\"runtime-version\" = \"${VERSION}\"" "$f" > "$f.tmp" && mv "$f.tmp" "$f" && updated=true
                  fi
                  if jq -e --arg v "${VERSION}" 'has("sdk-version") and .["sdk-version"] != $v' "$f" >/dev/null 2>&1; then
                    jq ".\"sdk-version\" = \"${VERSION}\"" "$f" > "$f.tmp" && mv "$f.tmp" "$f" && updated=true
                  fi
                else
                  notes+=("$f: invalid JSON, skipped")
                fi
              elif [[ "$f" =~ \.ya?ml$ ]]; then
                if yq eval '.' "$f" >/dev/null 2>&1; then
                  cur=$(yq eval '.["runtime-version"] // ""' "$f")
                  if [[ "$cur" != "${VERSION}" && -n "$cur" ]]; then
                    yq eval ".\"runtime-version\" = \"${VERSION}\"" -i "$f" && updated=true
                  fi
                  cur2=$(yq eval '.["sdk-version"] // ""' "$f")
                  if [[ "$cur2" != "${VERSION}" && -n "$cur2" ]]; then
                    yq eval ".\"sdk-version\" = \"${VERSION}\"" -i "$f" && updated=true
                  fi
                else
                  notes+=("$f: invalid YAML, skipped")
                fi
              else
                if grep -En 'runtime[-_ ]?version[[:space:]]*[:=]' "$f" >/dev/null 2>&1 || grep -En 'sdk[-_ ]?version' "$f" >/dev/null 2>&1; then
                  sed -E -i.bak -e "s/([\"']?runtime[-_ ]?version[\"']?[[:space:]]*[:=][[:space:]]*)(\"?)[0-9]+(\"?)/\1\2${VERSION}\3/g" \
                                -e "s/([\"']?sdk[-_ ]?version[\"']?[[:space:]]*[:=][[:space:]]*)(\"?)[0-9]+(\"?)/\1\2${VERSION}\3/g" "$f" || true
                  if ! cmp -s "$f" "$f.bak"; then updated=true; fi
                  rm -f "$f.bak" || true
                fi
              fi

              if [[ "$updated" == "true" ]]; then
                git add "$f"
                changed=true
              fi
            done

            if [[ "$changed" == "true" ]]; then
              git commit -m "chore: bump runtime-version and sdk-version to ${VERSION}" || true

              # Attempt to push to upstream repo first
              push_ok=true
              if git push -u origin "HEAD:${safe_branch}"; then
                echo "Pushed ${safe_branch} to upstream"
              else
                echo "Push failed for ${safe_branch} (may be protected)"
                push_ok=false
              fi

              # If push failed, and SKIP_PROTECTED is false, try to push to a fork (requires PAT)
              head_repo_full=""
              if [[ "${push_ok}" == "false" ]]; then
                if [[ "${SKIP_PROTECTED}" == "false" ]]; then
                  fork_full=$(ensure_fork)
                  if [[ -z "${fork_full}" ]]; then
                    echo "No fork available (PAT missing or fork creation failed). Will record failure and continue."
                  else
                    head_repo_owner=$(echo "${fork_full}" | cut -d'/' -f1)
                    head_repo_full="${fork_full}"
                    echo "Attempting to push to fork ${fork_full}..."
                    # add fork remote using PAT so we can push
                    git remote remove fork_remote || true
                    git remote add fork_remote "https://x-access-token:${PAT}@github.com/${fork_full}.git"
                    if git push -u fork_remote "HEAD:${safe_branch}"; then
                      echo "Pushed ${safe_branch} to fork ${fork_full}"
                    else
                      echo "Push to fork ${fork_full} failed as well."
                      head_repo_full=""
                    fi
                  fi
                fi
              else
                # push succeeded to upstream; head repo is upstream
                head_repo_full="${REPO}"
              fi

              # Build PR body
              PR_BODY="Automated change to bump Flatpak runtime-version and sdk-version to ${VERSION}.\n\nFiles changed:\n"
              git --no-pager diff --name-only HEAD~1 HEAD | while read -r fn; do PR_BODY="${PR_BODY}- ${fn}\n"; done
              if [ ${#notes[@]} -gt 0 ]; then
                PR_BODY="${PR_BODY}\nNotes:\n"
                for n in "${notes[@]}"; do PR_BODY="${PR_BODY}- ${n}\n"; done
              fi

              # Determine head for PR creation:
              # - If pushed to upstream: head = owner:branch (owner is repo owner)
              # - If pushed to fork: head = fork_owner:branch
              pr_head=""
              if [[ -n "${head_repo_full}" ]]; then
                fork_owner=$(echo "${head_repo_full}" | cut -d'/' -f1)
                pr_head="${fork_owner}:${safe_branch}"
              else
                # fallback: if we couldn't push anywhere, skip PR creation
                echo "Could not push branch to upstream or fork; skipping PR creation for ${target_branch}"
                popd >/dev/null
                git worktree remove "$workdir" --force || true
                continue
              fi

              # Check if a PR already exists with same head and base
              if pr_exists "${fork_owner}" "${safe_branch}" "${target_branch}"; then
                echo "A PR already exists for head ${pr_head} -> base ${target_branch}; skipping creation."
              else
                # Create PR
                pr_post_data=$(jq -n --arg title "Bump Flatpak runtime/sdk to ${VERSION}" \
                                      --arg head "${safe_branch}" \
                                      --arg base "${target_branch}" \
                                      --arg body "${PR_BODY}" \
                                      --arg head_repo_owner "${fork_owner}" \
                                      '{title:$title, head:$head, base:$base, body:$body, maintainer_can_modify:true}')
                # If head is a fork owner, the API expects head in format owner:branch. We'll use the fork_owner:branch parameter in the separate create call.
                # Use the upstream PR create endpoint and include head as "fork_owner:branch"
                create_payload=$(jq -n --arg title "Bump Flatpak runtime/sdk to ${VERSION}" --arg head "${pr_head}" --arg base "${target_branch}" --arg body "${PR_BODY}" '{title:$title, head:$head, base:$base, body:$body, maintainer_can_modify:true}')
                create_resp_code=$(curl -s -o /tmp/pr_create.json -w "%{http_code}" -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${REPO}/pulls" -d "$create_payload")
                if [[ "$create_resp_code" == "201" ]]; then
                  pr_url=$(jq -r .html_url /tmp/pr_create.json)
                  echo "Created PR: $pr_url"
                else
                  # If we get 422, print diagnostics
                  echo "Failed to create PR for ${safe_branch} -> ${target_branch}. Response code: $create_resp_code"
                  jq . /tmp/pr_create.json || true
                  # Try alternate: create with PAT if available
                  if [[ -n "${PAT:-}" ]]; then
                    echo "Retrying PR creation using PAT..."
                    create_resp_code2=$(curl -s -o /tmp/pr_create_pat.json -w "%{http_code}" -X POST -H "Authorization: token ${PAT}" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${REPO}/pulls" -d "$create_payload")
                    if [[ "$create_resp_code2" == "201" ]]; then
                      pr_url=$(jq -r .html_url /tmp/pr_create_pat.json)
                      echo "Created PR with PAT: $pr_url"
                    else
                      echo "Retry with PAT failed. Response code: $create_resp_code2"
                      jq . /tmp/pr_create_pat.json || true
                    fi
                  fi
                fi
              fi
            else
              echo "No changes for branch $target_branch"
            fi

            popd >/dev/null
            git worktree remove "$workdir" --force || true
          done

      - name: Summary
        run: echo "Workflow completed. Check Actions logs for details and any failures."
